---
title: "WGCNA_Analysis"
author: "Holly"
date: "November 3, 2020"
output: html_document
---

This is a WGCNA tutorial as created by The University of Texas at Austin found here: https://wikis.utexas.edu/display/bioiteam/Clustering+using+WGCNA

Files for this tutorial (in the WGCNA.zip folder) were dowloaded from here : https://wikis.utexas.edu/display/bioiteam/WGCNA+files and uploaded to the BIO_MSCI430_530_Sp20 directory. 

#Before running the following tutorial, make sure that the following required packages are installed and that you have set the proper working directory.
```{r}
#Only run the following to install BiocManager if not already installed
#if (!requireNamespace("BiocManager", quietly = TRUE))
    #install.packages("BiocManager")
#BiocManager::install()

# Only run the following commands once to install WGCNA and flashClust on your computer

#BiocManager::install("WGCNA")
#install.packages("flashClust") 

# Load WGCNA and flashClust libraries every time you open R
library(WGCNA)
library(flashClust)

#Set your current working directory (where all your files are)
setwd("C:/Users/hdoer/Desktop/thesis/new/data/DGE/Gopher_gill/Goph_map_to_copgil/WGCNA/") # Change the text within quotes as necessary.
```

# Step 1: Upload data into R and reformat for WGCNA

```{r}
# This creates an object called "datExpr" that contains the normalized counts file output from DESeq2
datExpr = read.csv("Goph_norm_expr_4_filt.csv")
# "head" the file to preview it
head(datExpr) # You see that genes are listed in a column named "X" and samples are in columns

```

Manipulate the file so it matches the format that WGCNA needs: 
```{r}
row.names(datExpr) = datExpr$X
datExpr$X = NULL
datExpr = as.data.frame(t(datExpr)) # now samples are rows and genes are columns
dim(datExpr) # 48 samples and 1000 genes (you will have many more genes in reality)
head(datExpr)
```

We want to check if there are any gene outliers by running the following: 
```{r}
gsg = goodSamplesGenes(datExpr, verbose = 3)
gsg$allOK
```
If the last statement returns TRUE, all genes have passed the cuts. If not, we remove the offending genes and samples from the data with the following:
```{r}
if (!gsg$allOK)
   {if (sum(!gsg$goodGenes)>0)
       printFlush(paste("Removing genes:", paste(names(datExpr)[!gsg$goodGenes], collapse= ", ")));
       if (sum(!gsg$goodSamples)>0)
           printFlush(paste("Removing samples:", paste(rownames(datExpr)[!gsg$goodSamples], collapse=", ")))
       datExpr= datExpr[gsg$goodSamples, gsg$goodGenes]
       }
 
```
Create an object called "datTraits" that contains your trait data
```{r}
datTraits = read.csv("Gopher_gill_phenotypic.csv")
head(datTraits)

#Then form a data frame analogous to expression data that will hold the clinical traits.
rownames(datTraits) = datTraits$Sample
datTraits$Sample = NULL
table(rownames(datTraits)==rownames(datExpr)) #should return TRUE if datasets align correctly, otherwise your names are out of order
head(datTraits)
```
You have finished uploading and formatting expression and trait data. Expression data is in datExpr, corresponding traits are datTraits. You can save these data into one file if you'd like, but you will not need to load it for the continuing code to run.

```{r}
save(datExpr, datTraits, file="SamplesAndTraits.RData")
#load("SamplesAndTraits.RData")
```

At this point you will need to identify sample outliers and choose a soft threshold power. These are easy to do and are well documented in the online tutorials.  It is suggested that you cluster samples by expression to identify any outliers before this step. This is provided in the attached R script.

From this plot, we would choose a power of 18 because it's the lowest power for which the scale free topology index reaches 0.90 (red line).

```{r}
# Choose a soft threshold power- USE A SUPERCOMPUTER IRL ------------------------------------
  
powers = c(c(1:10), seq(from =10, to=30, by=1)) #choosing a set of soft-thresholding powers
sft = pickSoftThreshold(datExpr, powerVector=powers, verbose =5, networkType="signed") #call network topology analysis function
  
sizeGrWindow(9,5)
par(mfrow= c(1,2))
cex1=0.9
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2], xlab= "Soft Threshold (power)", ylab="Scale Free Topology Model Fit, signed R^2", type= "n", main= paste("Scale independence"))
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2], labels=powers, cex=cex1, col="red")
abline(h=0.90, col="red")
plot(sft$fitIndices[,1], sft$fitIndices[,5], xlab= "Soft Threshold (power)", ylab="Mean Connectivity", type="n", main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1, col="red")
 
#from this plot, we would choose a power of 18 becuase it's the lowest power for which the scale free topology index reaches 0.90
```

#Step 2: Construct a gene co-expression network and identify modules

```{r}
#build a adjacency "correlation" matrix
enableWGCNAThreads()
softPower = 18
adjacency = adjacency(datExpr, power = softPower, type = "signed") #specify network type
head(adjacency)
```

Construct Networks- USE A SUPERCOMPUTER IRL -----------------------------

```{r}
#translate the adjacency into topological overlap matrix and calculate the corresponding dissimilarity:
TOM = TOMsimilarity(adjacency, TOMType="signed") # specify network type
dissTOM = 1-TOM
```

Generate Modules --------------------------------------------------------

First, generate a clustered gene tree
```{r}
# Generate a clustered gene tree
geneTree = flashClust(as.dist(dissTOM), method="average")
plot(geneTree, xlab="", sub="", main= "Gene Clustering on TOM-based dissimilarity", labels= FALSE, hang=0.04)
#This sets the minimum number of genes to cluster into a module
minModuleSize = 30
dynamicMods = cutreeDynamic(dendro= geneTree, distM= dissTOM, deepSplit=2, pamRespectsDendro= FALSE, minClusterSize = minModuleSize)
dynamicColors= labels2colors(dynamicMods)
MEList= moduleEigengenes(datExpr, colors= dynamicColors,softPower = softPower)
MEs= MEList$eigengenes
MEDiss= 1-cor(MEs)
METree= flashClust(as.dist(MEDiss), method= "average")
save(dynamicMods, MEList, MEs, MEDiss, METree, file= "Network_allSamples_signed_RLDfiltered.RData")
```
Then, this plots the tree showing how the eigengenes cluster together
```{r}
#plots tree showing how the eigengenes cluster together
#INCLUE THE NEXT LINE TO SAVE TO FILE
#pdf(file="clusterwithoutmodulecolors.pdf")
plot(METree, main= "Clustering of module eigengenes", xlab= "", sub= "")
#set a threhold for merging modules. In this example we are not merging so MEDissThres=0.0
MEDissThres = 0.0
merge = mergeCloseModules(datExpr, dynamicColors, cutHeight= MEDissThres, verbose =3)
mergedColors = merge$colors
mergedMEs = merge$newMEs
#INCLUE THE NEXT LINE TO SAVE TO FILE
#dev.off()
```

And finally, this plots the dendogram with the module colors below it.
```{r}
#plot dendrogram with module colors below it
#INCLUE THE NEXT LINE TO SAVE TO FILE
#pdf(file="cluster.pdf")
plotDendroAndColors(geneTree, cbind(dynamicColors, mergedColors), c("Dynamic Tree Cut", "Merged dynamic"), dendroLabels= FALSE, hang=0.03, addGuide= TRUE, guideHang=0.05)
moduleColors = mergedColors
colorOrder = c("grey", standardColors(50))
moduleLabels = match(moduleColors, colorOrder)-1
MEs = mergedMEs
#INCLUE THE NEXT LINE TO SAVE TO FILE
#dev.off()
```

#Step 3: Relate modules to external traits.

Correlate traits --------------------------------------------------------

First, define the number of genes and samples:
```{r}
#Define number of genes and samples
nGenes = ncol(datExpr)
nSamples = nrow(datExpr)
#Recalculate MEs with color labels
MEs0 = moduleEigengenes(datExpr, moduleColors)$eigengenes
MEs = orderMEs(MEs0)
moduleTraitCor = cor(MEs, datTraits, use= "p")
moduleTraitPvalue = corPvalueStudent(moduleTraitCor, nSamples)
```

Then, print the correlation heatmap between modules and traits

```{r}
#Print correlation heatmap between modules and traits
textMatrix= paste(signif(moduleTraitCor, 2), "\n(", 
                        signif(moduleTraitPvalue, 1), ")", sep= "")
dim(textMatrix)= dim(moduleTraitCor)
par(mar= c(6, 8.5, 3, 3))
```

Finally, display the correlation values with a heatmap plot:
```{r}
#display the correlation values with a heatmap plot
#INCLUE THE NEXT LINE TO SAVE TO FILE
#pdf(file="heatmap.pdf")
labeledHeatmap(Matrix= moduleTraitCor, 
            xLabels= names(datTraits), 
            yLabels= names(MEs), 
            ySymbols= names(MEs), 
            colorLabels= FALSE, 
            colors= blueWhiteRed(50), 
            textMatrix= textMatrix, 
            setStdMargins= FALSE, 
            cex.text= 0.5, 
            zlim= c(-1,1), 
            main= paste("Module-trait relationships"))
#INCLUE THE NEXT LINE TO SAVE TO FILE
#dev.off()
```

And volia! You should have a beautiful clustered heatmap showing the correlation of traits and genes.

For further analysis, if you wanted to pull out genes belonging to a certain module, you can use the following command:
```{r}
names(datExpr)[moduleColors=="yellow"]
```














